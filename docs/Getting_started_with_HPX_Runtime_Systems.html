<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<h1 id="getting-started-with-hpx-runtime-systems">Getting started with HPX Runtime Systems</h1>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#getting-started-a-summary">Summary</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#bootstrapping">Building and Installing</a></li>
<li><a href="#bootstrapping">Bootstrapping</a></li>
<li><a href="#configuration">Configuring</a></li>
<li><a href="#complete-the-build-and-install">Installing</a></li>
<li><a href="#running-jobs-on-computational-systems">Running</a></li>
<li><a href="#notes-on-building-hpx-on-arm">HPX on ARM</a></li>
<li><a href="#an-example-using-the-hpx-runtime-system">HPX Example</a></li>
<li><a href="#development-systems">HPX Development Systems</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>Welcome to the HPX runtime system library! In order to get started with HPX, you first need to know some basic information and how to go about using it. This document discusses how to get up and running quickly with the HPX Runtime System. Everything from unpacking and compilation of the distribution to execution of some tools.</p>
<p>This document is designed to be an extremely gentle introduction, so we included a fair amount of material that may already be very familiar to you. We'll refer to resources that can help advance users to pursue with HPX topics further.</p>
<h2 id="getting-started-a-summary">Getting Started (A Summary)</h2>
<p>Please find the quick summary to building HPX and running a network-capable HPX:</p>
<ol>
<li>Read the documentation.</li>
<li><p>Checkout HPX:</p>
<pre><code>$ cd where-you-want-hpx-to-install

$ git clone --recursive git@gitlab.crest.iu.edu:extreme/hpx.git</code></pre></li>
<li><p>There are several pre-requisites to successfully configure and run HPX which is detailed in further sections.</p></li>
</ol>
<h2 id="requirements">Requirements</h2>
<p>Before you begin to use the HPX runtime system, review the requirements given below. This detail about the hardware and software you will need.</p>
<h3 id="hardware">Hardware</h3>
<table>
<thead>
<tr class="header">
<th align="left">OS</th>
<th align="center">Arch</th>
<th align="right">Compilers</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Linux</td>
<td align="center">x86-64</td>
<td align="right">GCC</td>
</tr>
<tr class="even">
<td align="left">Linux</td>
<td align="center">ARMv7</td>
<td align="right">GCC</td>
</tr>
</tbody>
</table>
<p>HPX runtime system may compile on other platforms, but it is not guaranteed to do so. We do not test HPX with other platforms, so please be warned.</p>
<h3 id="software">Software</h3>
<p>Compiling HPX requires that you have several software packages installed. The table below lists those required packages. The package column is the usual name for the software package that HPX depends on. The Version column provides &quot;known to work&quot; versions of the package. The Notes column describes how HPX uses the package and provides other details.</p>
<table>
<thead>
<tr class="header">
<th align="left">Package</th>
<th align="center">Version</th>
<th align="right">Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Compilers</strong></td>
</tr>
<tr class="even">
<td align="left">GCC</td>
<td align="center">4.8.4 or newer</td>
<td align="right">Tested with 4.8.4, 4.9.1, 4.9.2</td>
</tr>
<tr class="odd">
<td align="left"><strong>Build System</strong></td>
</tr>
<tr class="even">
<td align="left">GNU Make</td>
<td align="center">3.81+</td>
<td align="right">Makefile/build processor</td>
</tr>
<tr class="odd">
<td align="left">GNU Autoconf</td>
<td align="center">2.6.9</td>
<td align="right">Configuration script builder (only required for developer builds)</td>
</tr>
<tr class="even">
<td align="left">GNU Automake</td>
<td align="center">1.15</td>
<td align="right">Aclocal macro generator (only required for developer builds)</td>
</tr>
<tr class="odd">
<td align="left">GNU M4</td>
<td align="center">1.4.17</td>
<td align="right">Macro processor for configuration</td>
</tr>
<tr class="even">
<td align="left">Libtool</td>
<td align="center">2.4.6</td>
<td align="right">Shared library manager (only required for developer builds)</td>
</tr>
<tr class="odd">
<td align="left">Pkg-config</td>
<td align="center"></td>
<td align="right">Only required for developer builds</td>
</tr>
<tr class="even">
<td align="left"><strong>Required Libraries</strong></td>
</tr>
<tr class="odd">
<td align="left">MPI (optional)</td>
<td align="center">1.6.3+</td>
<td align="right">Tested with 1.6.3, 1.6.5, 1.8.1, 1.8.4 MPICH 3.0.4, mvapich2/2.0b (Stampede)</td>
</tr>
<tr class="even">
<td align="left">Doxygen (Optional)</td>
<td align="center">1.8.7+</td>
<td align="right">Required to build the documentation</td>
</tr>
<tr class="odd">
<td align="left">Photon (embedded)</td>
</tr>
<tr class="even">
<td align="left">Jemalloc (embedded)</td>
<td align="center"></td>
<td align="right">HPX works with latest version as well.</td>
</tr>
<tr class="odd">
<td align="left">Hwloc (embedded)</td>
<td align="center"></td>
<td align="right">Used for OS-thread pinning and NUMA awareness</td>
</tr>
<tr class="even">
<td align="left">Uthash (embedded)</td>
<td align="center"></td>
<td align="right">C Macro for Hash tables and more.</td>
</tr>
<tr class="odd">
<td align="left">Valgrind (embedded)</td>
<td align="center"></td>
<td align="right">A memory error detector</td>
</tr>
<tr class="even">
<td align="left">libffi (embedded)</td>
<td align="center"></td>
<td align="right">A foreign function interface library</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol>
<li><p>HPX can build and run successfully without any network backend, but at present, MPI or Photon is required for networking by HPX. Photon can take advantage of RDMA over IB resulting in better performance</p></li>
<li><p>Only the C and architecture specific (x86_64, arm) assembly languages are needed so there's no need to build the other languages for HPX's purposes</p></li>
<li><p>If you want to make changes to the configure scripts, you will need GNU autoconf (2.69), M4(1.4.17), automake(1.15), libtool-2.4.6</p></li>
<li><p>Additionally, your compilation host is expected to have the usual plethora of Unix utilities</p></li>
</ol>
<h2 id="bootstrapping">Bootstrapping</h2>
<p>HPX provides a bootstrap script in its build. In the HPX directory run the bootstrap script using</p>
<pre><code>$ ./bootstrap</code></pre>
<p>Bootstrap is a bash script that generate the initialization required to create a configure script when using GNU autotools. This calls the autoreconf.</p>
<p>Building without MPI enables the SMP bootstrapper. This allows you to run HPX on a single node. However, if you launch HPX with -np &gt; 1 then either MPI / Photon transport should be enabled which is detailed in next section.</p>
<p>Note: ./bootstrap should not be used with release tarballs.</p>
<h2 id="configuration">Configuration</h2>
<h3 id="environment-dependencies">Environment dependencies</h3>
<p>The HPX configuration relies on <code>pkg-config</code> to look for installed packages. For custom builds using non-default configuration options, you need to</p>
<p>a) point to the appropriate <code>pkg-config</code> (.pc) files or</p>
<p>b) set the appropriate <code>LIBS</code> and <code>CFLAGS</code> environment variables.</p>
<p>See <code>./configure --help</code> for further details.</p>
<h3 id="getting-a-modern-host-gcc-toolchain">Getting a Modern Host GCC Toolchain</h3>
<p>The first step is to get a recent GCC toolchain installed.<br />Easy steps for installing GCC 4.8.2:</p>
<pre><code>$ sudo port install gcc48</code></pre>
<p>or can be built from the sources using</p>
<ol>
<li><p>Download all the three tar balls.</p>
<pre><code>$ cd $HOME/devel
$ wget http://mirrors.concertpass.com/gcc/releases/gcc-4.9.2/gcc-4.9.2.tar.gz
$ wget http://ftp.gnu.org/gnu/gdb/gdb-7.8.2.tar.gz
$ wget http://ftp.gnu.org/gnu/binutils/binutils-2.25.tar.gz</code></pre></li>
<li><p>Uncompress them all.</p>
<pre><code>$ tar xzf gcc-4.9.2.tar.gz
$ tar xzf gdb-7.8.2.tar.gz
$ tar xzf binutils-2.25.tar.gz</code></pre></li>
<li><p>Configure, make, and make install</p>
<pre><code>$ cd gcc-4.9.2
$ ./contrib/download_prerequisites
$ ./configure --prefix=&lt;YOUR_GCC_PREFIX&gt; --disable-nls --enable-languages=c,c++,fortran --with-system-glib --enable-__cxa_atexit --with-ppl --with-cloog --with-isl --enable-lto
$ make &amp;&amp; make install
$ cd gdb-7.8.2
$ ../gcc-4.9.2/contrib/download_prerequisites
$ ./configure --prefix=&lt;YOUR_GDB_PREFIX&gt; --disable-nls --enable-languages=c,c++,fortran --with-system-glib --enable-__cxa_atexit --with-ppl --with-cloog --with-isl --enable-lto
$ make &amp;&amp; make install
$ cd binutils-2.25
$ ../gcc-4.9.2/contrib/download_prerequisites
$ ./configure --prefix=&lt;YOUR_BINUTILS_PREFIX&gt; --disable-nls --enable-languages=c,c++,fortran --with-system-glib --enable-__cxa_atexit --with-ppl --with-cloog --with-isl --enable-lto
$ make &amp;&amp; make install</code></pre>
<p>For more details, check out the <a href="http://gcc.gnu.org/wiki/InstallingGCC">GCC wiki entry</a>.</p></li>
</ol>
<p>On cutter use</p>
<pre><code>$ module load gcc/4.9.2
$ module load gdb/7.8.2
$ module load openmpi/1.8.4_thread
$ module load valgrind
</code></pre>
<p>On BigRed2 use</p>
<pre><code>$ module unload PrgEnv-cray
$ module load PrgEnv-gnu</code></pre>
<p>No special steps is required on Stampede to use GCC</p>
<p>Notes on building HPX on ARM</p>
<p>Build HPX with armv7l-unknown-linux-gnueabihf as host and target. The HPX has been tested on Parallella-16 with most popular Linaro/Ubuntu OS's for ARM boards and they have hard-float platforms. More details about building HPX with ARM is detailed further in this manual.</p>
<h3 id="hpx-network-transports">HPX Network Transports</h3>
<p>HPX can be built with two network transport options: MPI and Photon. HPX can be built with one, both, or none of the network transports depending on application needs.<br />Each transport is runtime configurable. MPI and PMI are currently used as job launchers and bootstrap mechanism for HPX.</p>
<p>Note that if you are building with Photon, the libraries for the given<br />network interconnect you are targeting need to be present on the build system.<br />The two supported interconnects are InfiniBand (libibverbs and librdmacm) and<br />Cray's GEMINI and ARIES via uGNI (libugni). You may build with IBV and/or uGNI<br />support on a workstation where the development packages are installed, but<br />launching an HPX application with Photon requires that the actual network<br />devices be present so the library can initialize.</p>
<p>If you build with Photon and/or MPI on a system without networking, you may<br />still use the SMP transport to run applications that are not distributed.</p>
<h4 id="configuring-with-mpi">Configuring with MPI</h4>
<p>When building HPX, by default, HPX will try to find the pkg-config file<br /><code>ompi.pc</code> installed by Open MPI. (Instead, if you have MPICH installed, you need<br />to specify: <code>$ ./configure --with-mpi=mpich</code> will instruct <code>configure</code> to look<br />for <code>mpich.pc</code>.)</p>
<pre><code>b. If the relevant `pkg-config` file is not installed in the standard system
path (say, for a local MPI installation), append the relevant paths to
`$PKG_CONFIG_PATH`.  If OpenMPI is installed in `$HOME/opt/`; the configure
flags would be:

i.  $ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HOME/opt/lib/pkgconfig

ii. $ ./configure --with-mpi=ompi

c. Alternatively, you can also set `MPI_CFLAGS` and `MPI_LIBS` appropriately. Eg: `$ ./configure --with-mpi MPI_CFLAGS=$MPI_HOME/include MPI_LIBS=$MPI_HOME/lib`

d. Ensure that `mpicc` and `mpirun` are in your `$PATH`.</code></pre>
<p>On Cutter use</p>
<pre><code>$ module load openmpi/1.8.4_thread
$ ./configure --with-mpi=ompi</code></pre>
<p>On Stampede use</p>
<pre><code>$ module load intel/14.0.1.106
$ LDFLAGS=-L/opt/ofed/lib64 CPPFLAGS=-I/opt/ofed/include ./configure --with-mpi CC=mpicc</code></pre>
<p>On BigRed2: BigRed2 supports the MPI transport through the use of the <code>cc</code> Cray compiler wrapper:</p>
<pre><code>$ ./configure --with-mpi CC=cc</code></pre>
<h4 id="configuring-with-photon">Configuring with Photon</h4>
<p>The Photon transport is included in HPX within the contrib directory. To configure HPX with Photon use option <code>--enable-photon</code></p>
<p>On Cutter use</p>
<pre><code>$ ./configure --with-mpi=ompi --enable-photon</code></pre>
<p>On Stampede use</p>
<pre><code>$ module load intel/14.0.1.106
$ ./configure --enable-photon --with-mpi=/opt/apps/intel14/mvapich2/2.0b/lib/pkgconfig/mvapich2.pc</code></pre>
<p>On BigRed2 use</p>
<pre><code>$ module switch PrgEnv-cray PrgEnv-gnu
$ module load craype-hugepages8M
$ export CRAYPE_LINK_TYPE=dynamic
$ ./configure --enable-photon --with-mpi --with-ugni --with-hugetlbfs CC=cc </code></pre>
<p>The <code>--with-hugetlbfs</code> option causes the HPX heap to be mapped with huge pages, which is necessary for larger heaps on Cray machines. The hugepages module provides the environment necessary for compilation, and the size of the pages chosen has no effects. The size of hugepages used can be chosen by setting the <code>HUGETLB_DEFAULT_PAGE_SIZE</code> to one of the supported sizes. Loading any of the hugepages modules will set this variable appropriately, and, in addition, it will cause system malloc to use huge pages as well.</p>
<p>If you want to install photon from sources then get the sources using</p>
<pre><code>$ git clone git@gitlab.crest.iu.edu:damsl/photon.git
$ cd photon
$ mkdir my_photon_build
$ cd my_photon_build</code></pre>
<p>On Cutter use</p>
<pre><code>$ ./configure --with-mpi=ompi --prefix=/path/to/photon/installation</code></pre>
<p>On Stampede use</p>
<pre><code>$ ./configure --prefix=/path/to/photon/installation CC=mpicc LDFLAGS=-L/opt/ofed/lib64 CPPFLAGS=-I/opt/ofed/include --with-mpi  </code></pre>
<p>On Big Red 2 use</p>
<pre><code>$ ./configure --prefix=/path/to/photon/installation CC=cc --with-mpi --with-ugni</code></pre>
<p>Another option is to configure HPX with dynamic linking using Cray dynamic linking flags:</p>
<pre><code>$ export CRAYPE_LINK_TYPE=dynamic  
$ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/path/to/photon/installation:$PATH</code></pre>
<p>To configure HPX with external source photon, use the <code>--enable-external-photon</code> flag and set PHOTON_CFLAGS, PHOTON_CPPFLAGS, PHOTON_LIBS environment variable as appropriate.</p>
<p>If the HPX is built with multiple transports then by default Photon is<br />enabled. Users can choose different transporta using the option --hpx-transport<br />during at run-time: <code>--hpx-transport=&lt;mpi|photon|smp&gt;</code></p>
<h3 id="photon-hca-and-backend-selection">Photon HCA and backend selection</h3>
<p>The Photon default is to use the first detected IB device and active port. This behavior can be overridden with the following environment variable:</p>
<pre><code>$ export HPX_PHOTON_IBDEV=&quot;mlx4_0&quot;</code></pre>
<p>This string also acts as a device filter. For example,</p>
<pre><code>$ export HPX_PHOTON_IBDEV=&quot;mlx4_0:1+qib0:0&quot;</code></pre>
<p>will have Photon prefer device mlx4_0 and port 1 but will also use qib0 port 0 if detected.</p>
<p>Device names can be retrieved with ibv_devinfo on systems with IB Verbs support. If <code>HPX_PHOTON_IBDEV</code> is set to be blank, Photon will try to automatically select the right device.</p>
<p>(These parameters can also be set at run time using the command line option <code>--hpx-photon-ibdev=&lt;...&gt;</code>.)</p>
<p>The Photon default backend is also set to verbs. On BigRed2, or any other Cray system with a uGNI-supported interconnect, set the following environment variable:</p>
<pre><code>$ export HPX_PHOTON_BACKEND=ugni</code></pre>
<p>OR, use --hpx-photon-backend=ugni as a command line flag.</p>
<p>In addition, for huge pages builds, the size of huge pages can be controlled:</p>
<pre><code>$ export HUGETLB_DEFAULT_PAGE_SIZE=64M</code></pre>
<p>The list of supported sizes can be obtained as follows:</p>
<pre><code>$ module avail craype-hugepages</code></pre>
<h4 id="cutter-mpi-specifics">Cutter MPI specifics</h4>
<p>On Cutter, both Qlogic (qib0) and Mellanox (mlx4_0) HCAs are available. The MPI transport will use qib0 unless otherwise instructed. Additionally, OpenMPI on cutter has support for Performance Scaled Messaging that works with qib0.</p>
<p>To run MPI with the Mellanox HCA on cutter:</p>
<pre><code>$ mpirun -np N --mca mtl ^psm --mca btl_openib_if_include mlx4_0 &lt;...&gt;</code></pre>
<p>Photon will attempt to use the first discovered HCA with an active port. For most testing on cutter, the only variable needed is:</p>
<pre><code>$ export HPX_PHOTON_IBDEV=mlx4_0     // or qib0 if desired</code></pre>
<p>Four additional environment variables specific to Photon transport are recognized: HPX_PHOTON_ETHDEV,<br />HPX_PHOTON_IBDEV, HPX_PHOTON_USECMA, HPX_PHOTON_BACKEND but are typically not needed on cutter.</p>
<p>(Alternatively, these parameters can be set at run time using <code>--hpx-photon-ethdev=&lt;...&gt;</code>, etc.)</p>
<h4 id="stampede-specifics">Stampede specifics</h4>
<pre><code>$ export HPX_PHOTON_IBDEV=mlx4_0
$ ../configure --with-mpi=/opt/apps/intel14/mvapich2/2.0b/lib/pkgconfig/mvapich2.pc --enable-photon LDFLAGS=-L/opt/ofed/lib64 CPPFLAGS=-I/opt/ofed/include</code></pre>
<h3 id="on-the-c-swarm-cluster">On the C-SWARM Cluster</h3>
<pre><code>$ ompi/1.8.1-intel
$ module load gcc/4.9.2
$ ./configure --enable-photon --with-mpi=/opt/crc/openmpi/1.8.1/intel-14.0/lib/pkgconfig/ompi.pc</code></pre>
<h3 id="configuring-with-test-suite-enabled">Configuring with test-suite enabled</h3>
<p>To build and run the unit and performance testsuite enabled:</p>
<pre><code>$ ./configure --with-mpi --enable-photon --enable-testsuite
 
--with-tests-cmd=&quot;mpirun -np 2&quot; for instance can be used to specify the application launch command on various systems.</code></pre>
<h3 id="additional-optional-configure-options">Additional optional configure options</h3>
<p>Some additional optional features that HPX supports are the following</p>
<table>
<thead>
<tr class="header">
<th align="left">Option</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">--enable-logging</td>
<td align="center">Enable logging but not debug code. When this option is enabled we can get further debugging information when code is run using the flag --hpx-loglevel=$boot, sched, lco, gas, net, trans, parcel, all</td>
</tr>
<tr class="even">
<td align="left">--enable-debug</td>
<td align="center">Enable debug code</td>
</tr>
<tr class="odd">
<td align="left">--enable-profiling</td>
<td align="center">Enable profiling support</td>
</tr>
<tr class="even">
<td align="left">--enable-floodlight</td>
<td align="center">Enable Floodloght controller support</td>
</tr>
<tr class="odd">
<td align="left">--enable-doxygen</td>
<td align="center">Look for the doxygen program and enable construction of doxygen based documentation from the source code. This is disabled by default.</td>
</tr>
<tr class="even">
<td align="left">--enable-tutorial</td>
<td align="center">Enables the tutorial examples</td>
</tr>
</tbody>
</table>
<h2 id="complete-the-build-and-install">Complete the build and install</h2>
<p>To complete the build and install use:</p>
<pre><code>$ make
$ make install
$ make check (for testsuite) on compute node</code></pre>
<h2 id="running-jobs-on-computational-systems">Running jobs on Computational Systems</h2>
<p>HPX applications are executed on parallel computers. All the clusters have a batch server referred to as the cluster management server running on the headnode. Batch server monitors the status of the cluster and controls or monitors the various queues and job lists. For instance Cutter and Big Red II uses qsub interface into the batch server and lets the job to get requested resources on the cluster. Once the job was successfully scheduled, the user can run the code on compute nodes.<br />Here is the sample of commands to run the jobs on compute nodes (2 nodes)</p>
<pre><code>Cutter: qsub -I -l nodes=2 -l walltime=1:00:00 
Big Red II: qsub -I -l walltime=1:00:00 -l nodes=2:ppn=32 -q debug_cpu
Stampede: idev -N 2 -n 2 </code></pre>
<p>The nodes=2:ppn=32 directive will cause two compute nodes to be allocated for the application with each node of 32 cores.</p>
<p>More information and scheduling job options can be found at</p>
<pre><code>https://portal.tacc.utexas.edu/user-guides/stampede
https://kb.iu.edu/d/bdkt</code></pre>
<p>The HPX allows selecting the number of cores to run the code during run-time as well with the parameter --hpx-cores=$value.</p>
<p>Application launch command on various systems is as follows</p>
<pre><code>Cutter: mpirun
Stampede: ibrun
BigRed2: aprun</code></pre>
<p>Note that each launcher will have different options to control the same parameters. Important things to think about when launching a job is how many hpx processes to run per node and how many cores should each process take. The number of processes per node is controlled by the launcher, and hpx controls the number of cores that will be used.</p>
<h3 id="runtime-options">Runtime options</h3>
<p>HPX provides runtime options that can be specified on the command line or in the environment. The list of options can be obtained from any HPX program by adding <code>--help</code> option. The current list of options is as follows:</p>
<pre><code>HPX Runtime Options:
All of the following options can either be set through the
command-line using the flags given below, or through environment
variables of the form HPX_OPTION=value, where the option corresponds
to the flag suffix given below.
      --hpx-cores=cores         number of cores to run on
      --hpx-threads=threads     number of scheduler threads
      --hpx-stacksize=bytes     set HPX stack size
      --hpx-heapsize=bytes      set HPX per-PE global heap size
      --hpx-wfthreshold=tasks   bound on help-first tasks before work-first
                                  scheduling
      --hpx-gas=type            type of Global Address Space (GAS)  (possible
                                  values=&quot;default&quot;, &quot;smp&quot;, &quot;pgas&quot;,
                                  &quot;agas&quot;, &quot;pgas_switch&quot;, &quot;agas_switch&quot;)
      --hpx-boot=type           HPX bootstrap method to use  (possible
                                  values=&quot;default&quot;, &quot;smp&quot;, &quot;mpi&quot;,
                                  &quot;pmi&quot;)
      --hpx-transport=type      type of transport to use  (possible
                                  values=&quot;default&quot;, &quot;smp&quot;, &quot;mpi&quot;,
                                  &quot;portals&quot;, &quot;photon&quot;)
      --hpx-network=type        type of network to use  (possible
                                  values=&quot;default&quot;, &quot;smp&quot;, &quot;pwc&quot;,
                                  &quot;isir&quot;)
      --hpx-statistics          print HPX runtime statistics  (default=off)
      --hpx-sendlimit=requests  HPX transport-specific send limit
      --hpx-recvlimit=requests  HPX transport-specific recv limit
      --hpx-configfile=file     HPX runtime configuration file

Log options:
      --hpx-log-at=[localities] selectively output log information
      --hpx-log-level[=level]   set the logging level  (possible
                                  values=&quot;default&quot;, &quot;boot&quot;, &quot;sched&quot;,
                                  &quot;gas&quot;, &quot;lco&quot;, &quot;net&quot;, &quot;trans&quot;,
                                  &quot;parcel&quot;, &quot;action&quot;, &quot;all&quot;)

HPX Debug Options:
      --hpx-dbg-waitat=[locality]
                                wait for debugger at specific locality
      --hpx-dbg-waitonabort     call hpx_wait() inside of hpx_abort() for
                                  debugging  (default=off)
      --hpx-dbg-waitonsegv      call hpx_wait() for SIGSEGV for debugging
                                  (unreliable)  (default=off)
      --hpx-dbg-mprotectstacks  use mprotect() to bracket stacks to look for
                                  stack overflows  (default=off)

Tracing:
      --hpx-trace-classes=class set the event classes to trace  (possible
                                  values=&quot;parcel&quot;, &quot;pwc&quot;, &quot;sched&quot;,
                                  &quot;all&quot;)
      --hpx-trace-dir=dir       directory to output trace files
      --hpx-trace-filesize=# of events
                                set the size of each trace file
      --hpx-trace-at=[localities]
                                set the localities to trace at

PWC Network Options:
      --hpx-pwc-parcelbuffersize=bytes
                                set the size of p2p recv buffers for parcel
                                  sends
      --hpx-pwc-parceleagerlimit=bytes
                                set the largest eager parcel size (header
                                  inclusive)

Photon Transport Options:
      --hpx-photon-backend=type set the underlying network API to use
                                  (possible values=&quot;default&quot;, &quot;verbs&quot;,
                                  &quot;ugni&quot;)
      --hpx-photon-ibdev=device set a particular IB device (also a filter for
                                  device and port discovery, e.g.
                                  qib0:1+mlx4_0:2)
      --hpx-photon-ethdev=device
                                set a particular ETH device (for CMA mode only)
      --hpx-photon-ibport=integer
                                set a particular IB port
      --hpx-photon-usecma       enable CMA connection mode  (default=off)
      --hpx-photon-ledgersize=integer
                                set number of ledger entries
      --hpx-photon-eagerbufsize=bytes
                                set size of eager buffers
      --hpx-photon-smallpwcsize=bytes
                                set PWC small msg limit
      --hpx-photon-maxrd=integer
                                set max number of request descriptors
      --hpx-photon-defaultrd=integer
                                set default number of allocated descriptors</code></pre>
<h4 id="general-options">General Options</h4>
<p>Options in this group pertain to general properties of the hpx runtime execution. In the list of options above, these are the options without a heading.</p>
<h5 id="threads-and-cores">Threads and cores</h5>
<p>The <code>--hpx-threads</code> and <code>--hpx-cores</code> otpions control the threading aspects of HPX. <code>--hpx-threads</code> controls the number of workers threads started by HPX. <code>--hpx-cores</code> will in the future support oversubribing cores with multiple worker threads, but currently it has no effect when the number of cores is set to a different number than the number of threads, and it should not be used. Always use <code>--hpx-threads</code> to set the number of worker threads.</p>
<h5 id="memory-control">Memory control</h5>
<p>There are two kinds of memory controls for HPX. First, HPX reserves a global heap for all global allocations, both cyclic and non-cyclic. The <code>--hpx-stacksize</code> option controls the size of the stacks reserved for every HPX action. Note that HPX tasks and interrupts do not allocate their own stack.</p>
<h5 id="runtime-properties">Runtime properties</h5>
<p>Currently, the <code>--hpx-wfthreshold</code> is the only option to control the behavior of the HPX runtime. This option controls how many tasks will a worker spawn in help-first mode before switching to work-first mode. Help-first mode spawns any tasks created in the current tasks and continues with the current task. This can become a problem when a task spawns extreme amounts of other tasks, causing HPX's internal buffers to grow uncontrollably. In the work-first mode, a newly spawend task is processed before the continuation of the task that spawened it, preventing the uncontrollable buffer growth. If your task meet such characteristics, you can use this option to prevent HPX from crashing.</p>
<h5 id="selection-of-hpx-subsystems">Selection of HPX subsystems</h5>
<p>HPX comes with a selection of subsystems for different tasks. The 4 subsystems that can be selected include:</p>
<ul>
<li>Global memory subsystem with <code>--hpx-gas=type</code>. Supported options:</li>
<li><code>pgas</code>: HPX's implementation of partitioned global address space. Always selected on runs on 2 or more nodes.</li>
<li><code>smp</code>: HPX's shared memory implementation of GAS. Always selected for runs on 1 node.</li>
<li>Other options are only placeholders currently and will be supported in the future.</li>
<li>Boot subsystem with <code>--hpx-boot</code>. Supported options:</li>
<li><code>smp</code>: Shared memory boot.</li>
<li><code>mpi</code>: Use the MPI library for booting.</li>
<li><code>pmi</code>: Use the PMI library for booting.</li>
<li>Transport and network susystems with <code>--hpx-transport</code> and <code>--hpx-network=type</code>. Supported options:</li>
<li><code>photon</code> + <code>pwc</code>: Use a &quot;put with completion&quot; network implemented with photon.</li>
<li><code>mpi</code> + <code>isir</code>: Use MPI ISend and IRecv interfaces.</li>
<li>Other combinations of networks and transports are not currently supported.</li>
</ul>
<h5 id="receive-and-send-limits.">Receive and send limits.</h5>
<p>The ISIR network (<code>--hpx-network=isir</code>) supports send and receive limits with <code>--hpx-sendlimit</code> and <code>--hpx-recvlimit</code>. The limits control how many asynchronous requsets are created with MPI at any given time.</p>
<h4 id="logging-debugging-and-tracing-options">Logging, debugging, and tracing options</h4>
<p>The logging options <code>--hpx-log-at</code> and <code>--hpx-log-level</code> produce logging output for selected subsystems at selected localities. If no locality is selected, all localities will produce log messages. Log messages are not errors. Instead, they provide an insight into what the HPX runtime is doing &quot;under the hood.&quot;</p>
<p>The <code>wait</code> options in the debug section provide a way to stop the hpx runtime and wait for a debugger to be attached. The <code>--hpx-waitat</code> option causes HPX to stop at start of the application. A wait loop will be executed. The loop can be broken in the debugger with the following commands (assuming a freshly attached gdb):</p>
<pre><code>up 2
p i=1
c</code></pre>
<p>The two other <code>wait</code> options work in the same way. It is important to note that the <code>--hpx-dbg-waitonsegv</code> is implemented using non-portable techniques, and it is not guaranteed to work on all systems.</p>
<p>The <code>--hpx-dbg-mprotectstacks</code> uses the <code>mprotect()</code> interface to protect memory pages around task stacks. This provides a way to debug stack overflows, but if the incorrect memory access skips the proteceted page, the problem will not be detected.</p>
<h4 id="tracing">Tracing</h4>
<p>Note that in order to use the tracing interface, hpx must be compiled with the <code>--enable-instrumentation</code> option set.</p>
<p>There are four options that affect tracing:</p>
<ul>
<li><code>--hpx-trace-dir=&lt;directory name as string&gt;</code> (defaults to <code>&quot;/tmp&quot;</code> - which is strongly recommended) which is where the tracing infrastructure will save the traces</li>
<li><code>--hpx-trace-filesize=&lt;size as unsigned integer&gt;</code> which is a limit on the maximum trace file size</li>
<li><code>--hpx-trace-classes=&lt;list of classes as strings&gt;</code> which is the “class” of events to trace (possible values are <code>parcel</code>, <code>pwc</code>, <code>sched</code> and <code>all</code>)</li>
<li><code>--hpx-trace-at=&lt;list of ranks as integers&gt;</code> which can be set to a list of ranks at which to trace, or it can be set to <code>HPX_LOCALITY_ALL</code> or <code>HPX_LOCALITY_NONE</code> to turn tracing on or off everywhere</li>
</ul>
<p>Tracing records certain events and writes all the events for one rank to a file within a time-stamped subdirectory (which will be located in the specified trace directory) at that rank. Each event is assigned a time, accurate to the nearest microsecond.</p>
<p>The current trace file format is an ad hoc binary format that can be easily deserialized and processed.</p>
<h4 id="pohoton-and-pwc-options">Pohoton and PWC options</h4>
<h2 id="notes-on-building-hpx-on-arm">Notes on building HPX on ARM</h2>
<p>Here are some notes on building/testing HPX on ARM. This is primarily based on ARMv7 architecture on parallella-16.</p>
<h3 id="ensure-that-you-have-the-required-accessories">Ensure that you have the required accessories</h3>
<ul>
<li>Parallella-16 board</li>
<li>A high quality 2000mA rated 5V DC power supply with 5.5mm OD / 2.1mm ID center positive polarity plug.</li>
<li>An ethernet cable</li>
<li>UART connector to computer</li>
<li>A fan</li>
<li>16 GB Micro SD Card</li>
</ul>
<p>Note:</p>
<ol>
<li><p>The board does get hot so you have to take precautions to cool the board properly. Install the heatsink on the parallella board using the steps in: <a href="http://www.parallella.org/heatsink/">Installing the heatsink on the parallella board</a>. Before letting the board run for hours, ensure that the board doesn't overheat. Using table fan is highly advisable.</p></li>
<li><p>The board is ESD sensitive, please take the necessary precautions.</p></li>
</ol>
<h3 id="create-a-bootable-micro-sd-card">Create a bootable micro-SD Card</h3>
<p>Burn a fresh Micro-SD card using the latest distribution. The details of creating a parallella SD Card can be found from the link <a href="http://www.parallella.org/create-sdcard/">Creating a Parallella SD Card</a>. Under Mac OS X, the way I imaged it was like:</p>
<ul>
<li>Download the debian image from: <a href="http://stout.incntre.iu.edu/parallella/hpx-debian-parallella.img.bz2">HPX Debian parallella image</a> and unzip the image.</li>
</ul>
<p>The image can be flashed directly to your microSD and it contains an updated kernel with usb storage support. It also has openmpi-1.6.5 and libcheck installed with all the other dependencies needed to build hpx. If you just want the updated kernel, check the boot/ subdirectory.</p>
<ul>
<li>Insert the SD Card into your regular computer.</li>
<li>Find the device path of your SD card:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">diskutil</span> list</code></pre>
<ul>
<li>Unmount disk (but don't eject) the card:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">diskutil</span> unmountDisk [device] 
<span class="kw">Example</span>: 
$ <span class="kw">diskutil</span> unmountDisk /dev/disk1</code></pre>
<ul>
<li>Copy the image downloaded to the micro-SD card:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> dd if=[image] of=[device] bs=4m
<span class="kw">Example</span>: 
$ <span class="kw">sudo</span> dd if=hpx-debian-parallella.img of=/dev/disk1 bs=4m</code></pre>
<p>Please be patient, this takes a while.</p>
<ul>
<li>Eject the card:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">diskutil</span> eject [device]</code></pre>
<p>Done!</p>
<h3 id="connect-the-peripherals-and-apply-power">Connect the peripherals and apply power</h3>
<ol>
<li>Insert the Micro-SD card into parallella board.</li>
<li>Connect a UART connector to parallella. The Parallella board has a three pin 3.3V UART header located next to the RJ45 connector. The RXD pin is an input to the board and the TXD pin is an output from the board. The default UART configuration is as follows: (BAUD_RATE=115,200, DATA_BITS=8, STOP_BIT=1, PARITY=NONE, FLOW=XON/XOFF).</li>
<li>Connect ethernet cable</li>
<li>Connect power cable</li>
</ol>
<h3 id="build-and-run-hpx">Build and run HPX</h3>
<ul>
<li>Start the UART tty screen using the command:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> screen  /dev/ttyUSB0 115200</code></pre>
<p>Restart the parallella board and the system will boot and a login screen will appear. Once logged in,</p>
<ul>
<li>Grab the HPX code from the repository and build the code using the following commands:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">./bootstrap</span>
$ <span class="kw">./configure</span> --prefix=/path/to/hpx/installation --with-mpi CFLAGS=<span class="st">&quot;-O0 -g -mcpu=cortex-a9 -mfloat-abi=hard -mfpu=vfpv3&quot;</span> --enable-debug --enable-testsuite --enable-tutorial --enable-apps
$ <span class="kw">make</span> clean
$ <span class="kw">make</span></code></pre>
<p>Note: There are 2 cores on Parallella-16 boards. To run code on both cores set:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">export</span> <span class="ot">hpx_cores=</span>2
$ <span class="kw">export</span> <span class="ot">hpx_threads=</span>2</code></pre>
<h3 id="known-limitations">Known limitations</h3>
<ol>
<li>HPX on ARM works only with SMP and MPI transport.</li>
<li>Since, parallella board has only 1 GB of memory, some of the apps and examples might not work at higher scale due to memory limitation.</li>
</ol>
<h2 id="getting-started-with-hpx">Getting Started with HPX</h2>
<p>The remainder of this guide is meant to get you up and running with HPX and to give you some basic information about the HPX environment.</p>
<p>The later section of this guide describe the general layout of the HPX source tree, a simple example using the HPX, and links to find more information about HPX or to get help via e-mail.</p>
<h3 id="unpacking-the-hpx-archives">Unpacking the HPX Archives</h3>
<p>If you have the HPX distribution, you will need to unpack it before you can begin to compile it. The HPX source code is a TAR archive that is compressed with the gzip program.</p>
<p>hpx-x.y.z.tar.gz (Source release for the HPX libraries and tools, x.y.z marks the version number)</p>
<p>Git Mirror<br />The source code for the HPX can be obtained using the command</p>
<pre><code>$ git clone --recursive git@gitlab.crest.iu.edu:extreme/hpx.git</code></pre>
<p>Since the upstream repository is in Subversion, you should use <code>git pull --rebase</code> instead of git pull to avoid generating a non-linear history in your clone. To configure git pull to pass --rebase by default on the master branch, run the following command.</p>
<pre><code>$ git config branch.master.rebase true</code></pre>
<p>We use, the gitflow model for the development. The central repository holds the following main branches with an infinite lifetime:</p>
<ol>
<li><p>master</p></li>
<li><p>develop</p></li>
<li><p>hotfix</p></li>
</ol>
<p>We consider origin/master to be the main branch where the stable version of the source code exists, which reflects a production-ready state.</p>
<p>We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest developmental changes for the next release. When the source code in the develop branch is released, all of the changes will be merged into master branch and tagged with a release number.</p>
<h3 id="hpx-program-layout">HPX program Layout</h3>
<p>One useful source of information about the HPX source base is the HPX doxygen documentation available at hpx/docs. The following is a brief introduction to code layout:</p>
<p><code>hpx/bench</code> - NetBench, is a parcel based ping-pong test.</p>
<p><code>hpx/contrib</code> - consists of libraries which are embedded with HPX.</p>
<ol>
<li><p><code>hpx/controb/hwloc-1.10.0</code> - hwloc library helps to obtain the hierarchical map of key computing elements, such as: NUMA memory nodes, shared caches, processor sockets, processor cores, processing units (logical processors or &quot;threads&quot;) and even I/O devices. It gathers various attributes such as cache and memory information. Additionally it also assembles the topology information of the entire cluster at once.</p></li>
<li><p><code>hpx/contrib/uthash-fe01a6ad1b</code> - This is used for hash table lookup using a key.</p></li>
<li><p><code>hpx/contrib/jemalloc</code>, <code>hpx/contrib/jemalloc_hpx</code> - It is a general purpose malloc implementation that emphasizes fragmentation avoidance and scalable concurrent support.</p></li>
<li><p><code>hpx/contrib/photon</code> - Photon is a network backend for HPX. Photon can take advantage of RDMA over IB resulting in better performance.</p></li>
<li><p><code>hpx/contrib/valgrind</code> - valgrind is a memory error detector library. It can detect accessing memory one shouldn't, using undefined values, incorrect freeing of memory, overlapping src and dest pointers in memcpy and related functions, passing a negative value to the size parameter of a memory allocation function and memory leaks.</p></li>
<li><p><code>hpx/contrib/libffi</code> - is a foreign function interface library. It provides a C programming language interface for calling naively compiled functions given information about the target function at run time instead of compile time. It also implements opposite functionality: lib can produce a pointer to a function that can accept and decode any combination of arguments defined at run time. libffi is most ofter used as bridging technology between compiled and interpreted language implementations. It can also be used to implement plugin's, where the plugin's function signature are not known at the time of creating the host application.</p></li>
</ol>
<p><code>hpx/examples</code><br />This directory contains some simple examples of how to use the HPX.</p>
<p><code>hpx/include</code><br />This directory contains public header files used for HPX. The three main subdirectories of this directory are:</p>
<ol>
<li><p><code>hpx/include/hpx</code><br />This directory consist all of the HPX specific header files. This folder has types and functions defined for HPX actions, global addresses, attribute definitions, built-in compiler functions, futures, functions for allocating and using memory in the HPX global address space, HPX LCO interface, HPX parcel interface, HPX parallel loop interface, HPX process creation, HPX remote procedure call interface, HPX system interface, HPX thread interface, HPX high-resolution timer interface and HPX topology interface.</p></li>
<li><p><code>hpx/include/libhpx</code><br />This directory has types and functions defined for libhpx source directory. It deals with header files for bootstrapper, configuring HPX at run-time, locality, interface to the parcel network subsystem, gas, internal interface to the scheduler and HPX scheduler statistics, system, transport, worker threads, and util.</p></li>
<li><p><code>hpx/include/libsync</code><br />This directory consists of types and functions defined for libsync source directory. These have functions defined for CAS (counter pointer), a workstealing deque implementation, generic type definitions, lockable pointer, locks, M&amp;S two lock queues, single produce-single consumer concurrent queue, barriers, hashtable, synchronization primitives and atomics used in libhpx. It also has header file definition for synchronization and atomics interface in terms of craycc and gcc compiler.</p></li>
</ol>
<p><code>hpx/libhpx</code> - Contains source code for HPX implementation - HPX actions, bootstrapping, HPX calls, functions for debugging HPX, GAS (Global Address Space - smp, pgas), network layer, scheduler code (LCOs - collectives, channels, cvar, future, gencount, netfuture, semaphores, thread and worker code), and system related code.</p>
<p><code>hpx/libsync</code> - This consist of code for built in functions for atomic memory access and memory model aware atomic operations. Atomic variables are primarily used to synchronize shared memory accesses between threads.</p>
<p><code>hpx/tests</code> - This consist of unit and performance testsuite for HPX. The unit tests are based on check unit test framework. They do not cover all of the HPX API but parcels, threads, LCOs, and the global memory system have tests.</p>
<p><code>hpx/tutorial</code> - This consist of tutorial examples for beginners who are starting with HPX.</p>
<h2 id="an-example-using-the-hpx-runtime-system">An Example Using the HPX Runtime System</h2>
<p>This section explains the simple hello example. Writing applications with HPX is not difficult. The HPX API conforms to the usual semantics of the host language C. As any introduction to a new programming paradigm, we begin with writing the smallest possible program, &quot;Hello World&quot;. It explains the basic concept of HPX. The source code for this example can be found in hpx/examples/hello.c.</p>
<p>The &quot;Hello World!&quot; of HPX looks like</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;hpx/hpx.h&gt;

static int _hello_action(void *args) {
  printf(&quot;Hello World from %u.\n&quot;, hpx_get_my_rank());
  hpx_shutdown(HPX_SUCCESS);
}

int main(int argc, char *argv[argc]) {
  if (hpx_init(&amp;argc, &amp;argv) != 0)
    return -1;
  hpx_action_t hello;
  HPX_REGISTER_ACTION(_hello_action, &amp;hello);
  return hpx_run(&amp;hello, NULL, 0);
}</code></pre>
<p>We have to include a single file hpx.h</p>
<pre><code>#include&lt;hpx/hpx.h&gt;</code></pre>
<p>which imports all necessary declarations, for our HPX program. The program itself defines two functions: <code>main</code> and <code>_hello_action</code>.</p>
<p>As usual for any C program, the execution begins with the function main where all the action has to happen. In our case we use this function to initialize the HPX runtime system by calling <code>hpx_init</code>, which initializes the scheduler, network, global address space and locality. <code>hpx_init()</code> has to be called before any other HPX functions. Then we register the HPX action <code>_hello_action</code> using the macro <code>HPX_REGISTER_ACTION</code>. This should be called by the main native thread only, between the execution of <code>hpx_init()</code> and <code>hpx_run()</code>. This should not be called from an HPX lightweight thread.</p>
<p>Once the action is registered, main returns with <code>hpx_run(&amp;hello, NULL, 0)</code>; which executes the action <code>_hello_action</code> as an HPX-thread. An action is a wrapper for a function. By wrapping functions, HPX can send packets of work to different processing units. <code>HPX_REGISTER_ACTION</code> takes the name of the function that is to be wrapped and the name of the action that you are creating.</p>
<p>The function main returns only after <code>_hello_action</code> has returned and one of the HPX threads has called <code>hpx_shutdown</code>. It returns the value, which has been returned by <code>_hello_action</code> (in our case it will return HPX_SUCCESS).</p>
<p><code>hpx_run()</code> is called to run HPX. It starts the HPX runtime, and runs a given action. This creates an HPX &quot;main&quot; process, and calls the given action entry in the context of this process. The entry action is invoked only on the root locality. On termination, it deletes the main process and returns the status returned by the <code>hpx_shutdown()</code>. <code>hpx_run()</code> finalizes action registration, starts up any scheduler and native threads that need to run, and transfers all control into the HPX scheduler, beginning execution of the top action in the scheduler queue.</p>
<p>The <code>_hello_action</code> prints &quot;Hello World from 0&quot; and shuts down the HPX runtime system using the function <code>hpx_shutdown(HPX_SUCCESS)</code>; This terminates the scheduler and network. This causes the <code>hpx_run()</code> in the main native thread to return the code. The returned thread is executing the original native thread, and all supplementary scheduler threads and network will have been shutdown, and any library resources will have been cleaned up.</p>
<p>This program will print out the hello world message. The output of this program will look like this: Hello World from 0.</p>
<h2 id="development-systems">Development Systems</h2>
<p>HPX has been developed and tested on the following systems:</p>
<ul>
<li><p>C-SWARM at C-SWARM. The C-SWARM cluster has 72 Dual 8-core Intel Xeon E5-2650 v2 CPUs running at 2.60GHz, with 32 GBs or RAM. The interconnect uses Infiniband FDR Non-Blocking Mellanox HBA.</p></li>
<li><p>Cutter at CREST. Cutter is a cluster at CREST used for HPX development. It consists of 16 nodes with 32 GBs of RAM running dual 2.6 GHz Intel Xeon E5-2670s for a total of 16 cores per-node. Cutter runs Ubuntu 12.04.5.</p></li>
<li><p><a href="https://kb.iu.edu/d/bcqt">Big Red II</a> at Indiana University is a Cray XE6/XK7 with 1020 compute nodes. Nodes are a mix of dual AMD Opteron 16-core Abu Dhabi CPUs with 64 GBs of RAM, and single Opteron 16-core Interlagos CPUs and an NVIDIA Tesla K20 Gpu accelerator with 32 GBs of RAM. All compute nodes are connected through the Cray Gemini interconnects. Big Red II runs Cray Linux Environment (based on SUSE Linux SLES 11).</p></li>
<li><p><a href="https://www.nersc.gov/users/computational-systems/edison/">Edison</a> at the National Energy Research Scientific Computing Center is a Cray XC30. Edison's queues support job sizes up to 5462 nodes (131,088 cores). Edison nodes have dual 12-core Intel Xeon E5-2695 v2 CPUs at 2.40GHz and 64 GB of RAM.</p></li>
<li><p><a href="https://portal.tacc.utexas.edu/user-guides/stampede#overview">Stampede</a> at the Texas Advanced Computing Center consists of more than 6400 nodes with dual Intel Xeon E5-2680 CPUs running at 2.8 GHz with an additional Intel Xeon Phi SE10P Coprocessor and 32 GBs of RAM (with an additional 8 GBs available for coprocessors). Large memory nodes are also available. The OS is CentOS release 6.6. The network on Stampede uses Mellanox FDR InfiniBand. Normal production runs are limited to 256 nodes.</p></li>
</ul>
</body>
</html>
