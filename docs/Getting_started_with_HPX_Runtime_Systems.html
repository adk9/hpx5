<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<h1 id="getting-started-with-hpx">Getting started with HPX</h1>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#other-ways-to-get-help">Other Ways to Get Help</a></li>
<li><a href="#getting-started-a-summary">Summary</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#bootstrapping">Building and Installing</a></li>
<li><a href="#configuration">Configuring</a></li>
<li><a href="#complete-the-build-and-install">Installing</a></li>
<li><a href="#bootstrap-for-developer-builds">Developer Builds</a></li>
<li><a href="#running-jobs-on-computational-systems">Running</a></li>
<li><a href="#notes-on-building-hpx-on-arm">HPX on ARM</a></li>
<li><a href="#an-example-using-the-hpx-runtime-system">HPX Example</a></li>
<li><a href="#development-systems">HPX Development Systems</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>Welcome to the HPX runtime system library! This document discusses how to get up and running quickly with the HPX. Everything from building to executing some of the HPX examples. Since this document is designed to be an extremely gentle introduction, we included a fair amount of material that may already be very familiar to you. We'll refer to resources that can help expert users to pursue with advanced HPX topics further.</p>
<h2 id="other-ways-to-get-help">Other Ways to Get Help</h2>
<p>There is a hpx-users mailing list for support for problems building, installing, and using HPX. You can subscribe at <a href="http://www.crest.iu.edu/mailman/listinfo.cgi/hpx-users"><a href="http://www.crest.iu.edu/mailman/listinfo.cgi/hpx-users" class="uri">http://www.crest.iu.edu/mailman/listinfo.cgi/hpx-users</a></a>.</p>
<h2 id="getting-started-a-summary">Getting Started (A Summary)</h2>
<p><em>Cray users must set <code>export CRAYPE_LINK_TYPE=dynamic</code> to use HPX.</em></p>
<p>Please find the quick summary to building HPX and running a network-capable HPX:</p>
<ol>
<li>Read the documentation.</li>
<li><p>Checkout HPX:</p>
<pre><code>$ cd where-you-want-hpx-to-install

$ git clone --recursive git@gitlab.crest.iu.edu:extreme/hpx.git</code></pre></li>
<li><p>There are several pre-requisites to successfully configure and run HPX which is detailed in further sections.</p></li>
</ol>
<h2 id="requirements">Requirements</h2>
<p>Before you begin to use the HPX runtime system, review the requirements given below. This detail about the hardware and software you will need.</p>
<h3 id="hardware">Hardware</h3>
<table>
<thead>
<tr class="header">
<th align="left">OS</th>
<th align="center">Arch</th>
<th align="right">Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Linux</td>
<td align="center">x86-64</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left">Linux</td>
<td align="center">ARMv7</td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p>HPX runtime system may compile on other platforms, but it is not guaranteed to do so. We do not test HPX with other platforms.</p>
<h3 id="software">Software</h3>
<p>Compiling HPX requires that you have several software packages installed. The table below lists those required packages. The package column is the usual name for the software package that HPX depends on. The Version column provides &quot;known to work&quot; versions of the package. The Notes column describes how HPX uses the package and provides other details.</p>
<table>
<thead>
<tr class="header">
<th align="left">Package</th>
<th align="center">Version</th>
<th align="right">Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Compilers</strong></td>
</tr>
<tr class="even">
<td align="left">C99 compatible compiler</td>
<td align="center">gcc</td>
<td align="right">Tested with 4.6.4, 4.8.4, 4.9.2</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="center">clang</td>
<td align="right">Tested with 3.6, 3.5 and earlier are known to be broken</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center">icc</td>
<td align="right">Tested with 15.0.1</td>
</tr>
<tr class="odd">
<td align="left"><strong>Build System</strong></td>
</tr>
<tr class="even">
<td align="left">GNU Make</td>
<td align="center">3.81+</td>
<td align="right">Makefile/build processor</td>
</tr>
<tr class="odd">
<td align="left">GNU Autoconf</td>
<td align="center">2.6.9</td>
<td align="right">Configuration script builder (only required for developer builds)</td>
</tr>
<tr class="even">
<td align="left">GNU Automake</td>
<td align="center">1.15</td>
<td align="right">Aclocal macro generator (only required for developer builds)</td>
</tr>
<tr class="odd">
<td align="left">GNU M4</td>
<td align="center">1.4.17</td>
<td align="right">Macro processor for configuration</td>
</tr>
<tr class="even">
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">Libtool</td>
<td align="center">2.4.6</td>
<td align="right">Shared library manager (only required for developer builds)</td>
</tr>
<tr class="even">
<td align="left">Pkg-config</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"><strong>Library Dependencies</strong></td>
</tr>
<tr class="even">
<td align="left">MPI (optional)</td>
<td align="center">1.6.3+</td>
<td align="right">Tested with 1.6.3, 1.6.5, 1.8.1, 1.8.4 MPICH 3.0.4, mvapich2/2.0b (Stampede)</td>
</tr>
<tr class="odd">
<td align="left">Doxygen (Optional)</td>
<td align="center">1.8.7+</td>
<td align="right">Required to build the documentation</td>
</tr>
<tr class="even">
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">Photon (included)</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left">Jemalloc (included)</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left">Hwloc (included)</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left">Uthash (included)</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left">libffi (included)</td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol>
<li><p>HPX can build and run successfully without any network backend, but at present, MPI or Photon is required for networking by HPX.</p></li>
<li><p>If you want to make changes to the configure scripts, you will need GNU autoconf (2.69), M4(1.4.17), automake(1.15), libtool-2.4.6.</p></li>
</ol>
<h2 id="configuration">Configuration</h2>
<h3 id="environment-dependencies">Environment dependencies</h3>
<p>The HPX configuration uses <code>pkg-config</code> to find dependencies. For custom builds using non-default configuration options, you need to</p>
<p>a) point to the appropriate <code>pkg-config</code> (.pc) files or</p>
<p>b) set the appropriate <code>LIBS</code> and <code>CFLAGS</code> environment variables.</p>
<p>See <code>./configure --help</code> for further details.</p>
<h3 id="hpx-network-transports">HPX Network Transports</h3>
<p>HPX can be built with two network transport options: MPI and Photon. HPX can be built with one, both, or none of the network transports depending on application needs.<br />Each transport is runtime configurable. MPI and PMI are currently used as job launchers and bootstrap mechanism for HPX.</p>
<p>Note that if you are building with Photon, the libraries for the given<br />network interconnect you are targeting need to be present on the build system.<br />The two supported interconnects are InfiniBand (libibverbs and librdmacm) and<br />Cray's GEMINI and ARIES via uGNI (libugni). You may build with IBV and/or uGNI<br />support on a workstation where the development packages are installed, but<br />launching an HPX application with Photon requires that the actual network<br />devices be present so the library can initialize.</p>
<p>If you build with Photon and/or MPI on a system without networking, you may<br />still use the SMP transport to run applications that are not distributed.</p>
<h4 id="configuring-with-mpi">Configuring with MPI</h4>
<p>When building HPX, by default, HPX will try to find the pkg-config file<br /><code>ompi.pc</code> installed by Open MPI. (Instead, if you have MPICH installed, you need<br />to specify: <code>$ ./configure --with-mpi=mpich</code> will instruct <code>configure</code> to look<br />for <code>mpich.pc</code>.)</p>
<pre><code>a. If the relevant `pkg-config` file is not installed in the standard system
path (say, for a local MPI installation), append the relevant paths to
`$PKG_CONFIG_PATH`.  If OpenMPI is installed in `$HOME/opt/`; the configure
flags would be:

i.  $ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HOME/opt/lib/pkgconfig

ii. $ ./configure --with-mpi=ompi

b. Alternatively, you can also set `MPI_CFLAGS` and `MPI_LIBS` appropriately. Eg: `$ ./configure --with-mpi MPI_CFLAGS=$MPI_HOME/include MPI_LIBS=$MPI_HOME/lib`

c. Alternatively, you may use `CC=mpicc`.</code></pre>
<p>On Cutter use</p>
<pre><code>$ module load openmpi/1.8.4_thread
$ ./configure --with-mpi=ompi</code></pre>
<p>On Stampede use</p>
<pre><code>$ module load intel/14.0.1.106
$ LDFLAGS=-L/opt/ofed/lib64 CPPFLAGS=-I/opt/ofed/include ./configure --with-mpi CC=mpicc</code></pre>
<p>On BigRed2: BigRed2 supports the MPI transport through the use of the <code>cc</code> Cray compiler wrapper:</p>
<pre><code>$ ./configure --with-mpi CC=cc</code></pre>
<h4 id="configuring-with-photon">Configuring with Photon</h4>
<p>The Photon transport is included in HPX within the contrib directory. To configure HPX with Photon use option <code>--enable-photon</code></p>
<p>On Cutter use</p>
<pre><code>$ ./configure --with-mpi=ompi --enable-photon</code></pre>
<p>On Stampede use</p>
<pre><code>$ module load intel/14.0.1.106
$ ./configure --enable-photon --with-mpi=/opt/apps/intel14/mvapich2/2.0b/lib/pkgconfig/mvapich2.pc</code></pre>
<p>On BigRed2 use</p>
<pre><code>$ module switch PrgEnv-cray PrgEnv-gnu
$ module load craype-hugepages4M
$ export CRAYPE_LINK_TYPE=dynamic
$ ./configure --enable-photon --with-mpi=cray-mpich HPX_PHOTON_CARGS=--with-ugni --with-hugetlbfs CC=cc </code></pre>
<p>The <code>--with-hugetlbfs</code> option causes the HPX heap to be mapped with huge pages, which is necessary for larger heaps on Cray machines. The hugepages modules provide the environment necessary for compilation.</p>
<p>If you want to install photon from sources then get the sources using</p>
<pre><code>$ git clone git@gitlab.crest.iu.edu:damsl/photon.git
$ cd photon
$ mkdir my_photon_build
$ cd my_photon_build</code></pre>
<p>On Cutter use</p>
<pre><code>$ ./configure --with-mpi=ompi --prefix=/path/to/photon/installation</code></pre>
<p>On Stampede use</p>
<pre><code>$ ./configure --prefix=/path/to/photon/installation CC=mpicc LDFLAGS=-L/opt/ofed/lib64 CPPFLAGS=-I/opt/ofed/include --with-mpi  </code></pre>
<p>On Big Red 2 use</p>
<pre><code>$ ./configure --prefix=/path/to/photon/installation CC=cc --with-mpi --with-ugni</code></pre>
<p>To configure HPX with external source photon, use the <code>--enable-external-photon</code> flag and set PHOTON_CFLAGS, PHOTON_CPPFLAGS, PHOTON_LIBS environment variable as appropriate.</p>
<h3 id="photon-hca-and-backend-selection">Photon HCA and backend selection</h3>
<p>The Photon default is to use the first detected IB device and active port. This behavior can be overridden with the following environment variable:</p>
<pre><code>$ export HPX_PHOTON_IBDEV=&quot;mlx4_0&quot;</code></pre>
<p>This string also acts as a device filter. For example,</p>
<pre><code>$ export HPX_PHOTON_IBDEV=&quot;mlx4_0:1+qib0:0&quot;</code></pre>
<p>will have Photon prefer device mlx4_0 and port 1 but will also use qib0 port 0 if detected.</p>
<p>Device names can be retrieved with ibv_devinfo on systems with IB Verbs support. If <code>HPX_PHOTON_IBDEV</code> is set to be blank, Photon will try to automatically select the right device.</p>
<p>(These parameters can also be set at run time using the command line option <code>--hpx-photon-ibdev=&lt;...&gt;</code>.)</p>
<p>The Photon default backend is also set to verbs. On BigRed2, or any other Cray system with a uGNI-supported interconnect, set the following environment variable:</p>
<pre><code>$ export HPX_PHOTON_BACKEND=ugni</code></pre>
<p>OR, use --hpx-photon-backend=ugni as a command line flag.</p>
<p>The list of supported sizes can be obtained as follows:</p>
<pre><code>$ module avail craype-hugepages</code></pre>
<h4 id="cutter-mpi-specifics">Cutter MPI specifics</h4>
<p>On Cutter, both Qlogic (qib0) and Mellanox (mlx4_0) HCAs are available. The MPI transport will use qib0 unless otherwise instructed. Additionally, OpenMPI on cutter has support for Performance Scaled Messaging that works with qib0.</p>
<p>To run MPI with the Mellanox HCA on cutter:</p>
<pre><code>$ mpirun -np N --map-by node:PE=C --mca mtl ^psm --mca btl_openib_if_include mlx4_0 &lt;...&gt;</code></pre>
<p>Photon will attempt to use the first discovered HCA with an active port. For most testing on cutter, the only variable needed is:</p>
<pre><code>$ export HPX_PHOTON_IBDEV=mlx4_0     // or qib0 if desired</code></pre>
<p>Four additional environment variables specific to Photon transport are recognized: HPX_PHOTON_ETHDEV,<br />HPX_PHOTON_IBDEV, HPX_PHOTON_USECMA, HPX_PHOTON_BACKEND.</p>
<p>(Alternatively, these parameters can be set at run time using <code>--hpx-photon-ethdev=&lt;...&gt;</code>, etc.)</p>
<h4 id="stampede-specifics">Stampede specifics</h4>
<pre><code>$ export HPX_PHOTON_IBDEV=mlx4_0
$ ../configure --with-mpi=/opt/apps/intel14/mvapich2/2.0b/lib/pkgconfig/mvapich2.pc --enable-photon LDFLAGS=-L/opt/ofed/lib64 CPPFLAGS=-I/opt/ofed/include</code></pre>
<h3 id="on-the-c-swarm-cluster">On the C-SWARM Cluster</h3>
<pre><code>$ ompi/1.8.1-intel
$ module load gcc/4.9.2
$ ./configure --enable-photon --with-mpi=/opt/crc/openmpi/1.8.1/intel-14.0/lib/pkgconfig/ompi.pc</code></pre>
<h3 id="configuring-with-test-suite-enabled">Configuring with test-suite enabled</h3>
<p>To build and run the unit and performance testsuite enabled:</p>
<pre><code>$ ./configure --with-mpi --enable-photon --enable-testsuite
 
--with-tests-cmd=&quot;mpirun -np 2 --map-by node:PE=16&quot; for instance can be used to specify the application launch command on various systems.</code></pre>
<h3 id="additional-optional-configure-options">Additional optional configure options</h3>
<p>Some additional optional features that HPX supports are the following</p>
<table>
<thead>
<tr class="header">
<th align="left">Option</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">--enable-logging</td>
<td align="center">Enable logging (--hpx-log-level, --hpx-log-at)</td>
</tr>
<tr class="even">
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">--enable-debug</td>
<td align="center">Enable debugging (--hpx-dbg prefixed flags and runtime checks)</td>
</tr>
<tr class="even">
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">--enable-instrumentation</td>
<td align="center">Enable instrumentation (expensive).</td>
</tr>
<tr class="even">
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">--enable-doxygen</td>
<td align="center">Build doxygen documentation.</td>
</tr>
<tr class="even">
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">--enable-tutorial</td>
<td align="center">Build tutorial examples.</td>
</tr>
<tr class="even">
<td align="left"></td>
</tr>
</tbody>
</table>
<h2 id="complete-the-build-and-install">Complete the build and install</h2>
<p>To complete the build and install use:</p>
<pre><code>$ make
$ make install
$ make check (for testsuite) on compute node</code></pre>
<h2 id="bootstrap-for-developer-builds">Bootstrap for developer builds</h2>
<p>HPX releases have already been bootstrapped. Developers using other branches will need to bootstrap before configuration. In the HPX directory run the bootstrap script. You may need updated tools, which can be installed using the <code>scripts/setup_autotools.sh</code> script.</p>
<pre><code>$ ./bootstrap</code></pre>
<h2 id="running-jobs-on-computational-systems">Running jobs on Computational Systems</h2>
<p>HPX applications are executed on parallel computers. All the clusters have a batch server referred to as the cluster management server running on the headnode. Batch server monitors the status of the cluster and controls or monitors the various queues and job lists. For instance Cutter and Big Red II uses qsub interface into the batch server and lets the job to get requested resources on the cluster. Once the job was successfully scheduled, the user can run the code on compute nodes.<br />Here is the sample of commands to run the jobs on compute nodes (2 nodes)</p>
<pre><code>Cutter: qsub -I -l nodes=2:ppn=16 -l walltime=1:00:00 
Big Red II: qsub -I -l walltime=1:00:00 -l nodes=2:ppn=32 -q debug_cpu
Stampede: idev -N 2 -n 2 </code></pre>
<p>The nodes=2:ppn=32 directive will cause two compute nodes to be allocated for the application with each node of 32 cores.</p>
<p>More information and scheduling job options can be found at</p>
<pre><code>https://portal.tacc.utexas.edu/user-guides/stampede
https://kb.iu.edu/d/bdkt</code></pre>
<p>HPX will use the core count and affinity set by the launcher.</p>
<p>Application launch command on various systems is as follows</p>
<pre><code>Cutter: mpirun
Stampede: ibrun
BigRed2: aprun</code></pre>
<p>Note that each launcher will have different options to control the same parameters. Important things to think about when launching a job is how many hpx processes to run per node and how many cores should each process take. The number of processes per node is controlled by the launcher, and hpx controls the number of cores that will be used.</p>
<h3 id="runtime-options">Runtime options</h3>
<p>HPX provides runtime options that can be specified on the command line or in the environment. The list of options can be obtained from any HPX program by adding <code>--hpx-help</code> option.</p>
<h4 id="general-options">General Options</h4>
<pre class="sourceCode bash"><code class="sourceCode bash">      <span class="kw">--hpx-help</span>                print HPX help  (default=off)
      <span class="kw">--hpx-cores</span>=cores         number of cores to run on
      <span class="kw">--hpx-threads</span>=threads     number of scheduler threads
      <span class="kw">--hpx-stacksize</span>=bytes     set HPX stack size
      <span class="kw">--hpx-heapsize</span>=bytes      set HPX per-PE global heap size
      <span class="kw">--hpx-wfthreshold</span>=tasks   bound on help-first tasks before 
                                  <span class="kw">work-first</span> scheduling
      <span class="kw">--hpx-gas</span>=type            type of Global Address Space (GAS)  
                                  <span class="kw">(possible</span> values=<span class="st">&quot;default&quot;</span>, <span class="st">&quot;smp&quot;</span>, 
                                  <span class="st">&quot;pgas&quot;</span>, <span class="st">&quot;agas&quot;</span><span class="kw">)</span>
      <span class="kw">--hpx-boot</span>=type           HPX bootstrap method to use  
                                  <span class="kw">(possible</span> values=<span class="st">&quot;default&quot;</span>, <span class="st">&quot;smp&quot;</span>, 
                                  <span class="st">&quot;mpi&quot;</span>, <span class="st">&quot;pmi&quot;</span><span class="kw">)</span>
      <span class="kw">--hpx-transport</span>=type      type of transport to use  (possible 
                                  <span class="ot">values=</span><span class="st">&quot;default&quot;</span>, <span class="st">&quot;mpi&quot;</span>, <span class="st">&quot;portals&quot;</span>, 
                                  <span class="st">&quot;photon&quot;</span>)
      <span class="kw">--hpx-network</span>=type        type of network to use  (possible 
                                  <span class="ot">values=</span><span class="st">&quot;default&quot;</span>, <span class="st">&quot;smp&quot;</span>, <span class="st">&quot;pwc&quot;</span>, 
                                  <span class="st">&quot;isir&quot;</span>)
      <span class="kw">--hpx-statistics</span>          print HPX runtime statistics  
                                  <span class="kw">(</span><span class="ot">default=</span>off<span class="kw">)</span>
      <span class="kw">--hpx-configfile</span>=file     HPX runtime configuration file</code></pre>
<p>Options in this group pertain to general properties of the hpx runtime execution. In the list of options above, these are the options without a heading.</p>
<h5 id="system-threads">System Threads</h5>
<p>The <code>--hpx-threads</code> controls the threading aspects of HPX. <code>--hpx-threads</code> controls the number of workers threads started by HPX.</p>
<h5 id="memory-control">Memory control</h5>
<p>There are two kinds of memory controls for HPX. First, HPX reserves a global heap for all global allocations, both cyclic and non-cyclic. The <code>--hpx-stacksize</code> option controls the size of the stacks reserved for every HPX action. Note that HPX tasks and interrupts do not allocate their own stack.</p>
<h5 id="runtime-properties">Runtime properties</h5>
<p>Currently, the <code>--hpx-wfthreshold</code> is the only option to control the behavior of the HPX runtime. This option controls how many tasks will a worker spawn in help-first mode before switching to work-first mode. Help-first mode spawns any tasks created in the current tasks and continues with the current task. This can become a problem when a task spawns extreme amounts of other tasks, causing HPX's internal buffers to grow uncontrollably. In the work-first mode, a newly spawend task is processed before the continuation of the task that spawened it, preventing the uncontrollable buffer growth. If your task meet such characteristics, you can use this option to prevent HPX from crashing.</p>
<h5 id="selection-of-hpx-subsystems">Selection of HPX subsystems</h5>
<p>HPX comes with a selection of subsystems for different tasks. The 4 subsystems that can be selected include:</p>
<ul>
<li>Global memory subsystem with <code>--hpx-gas=type</code>. Supported options:</li>
<li><code>pgas</code>: HPX's implementation of partitioned global address space. Always selected on runs on 2 or more nodes.</li>
<li><code>smp</code>: HPX's shared memory implementation of GAS. Always selected for runs on 1 node.</li>
<li>Other options are only placeholders currently and will be supported in the future.</li>
<li>Boot subsystem with <code>--hpx-boot</code>. Supported options:</li>
<li><code>smp</code>: Shared memory boot.</li>
<li><code>mpi</code>: Use the MPI library for booting.</li>
<li><code>pmi</code>: Use the PMI library for booting.</li>
<li>Transport and network susystems with <code>--hpx-transport</code> and <code>--hpx-network=type</code>. Supported options:</li>
<li><code>photon</code> + <code>pwc</code>: Use a &quot;put with completion&quot; network implemented with photon.</li>
<li><code>mpi</code> + <code>isir</code>: Use MPI ISend and IRecv interfaces.</li>
<li>Other combinations of networks and transports are not currently supported.</li>
</ul>
<h4 id="logging-options">Logging Options</h4>
<p>Note that in order to use the logging options, <code>--enable-logging</code> must be set at configuration time.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">      <span class="kw">--hpx-log-at</span>=[localities] selectively output log information
      <span class="kw">--hpx-log-level</span>[=level]   set the logging level  (possible 
                                  <span class="ot">values=</span><span class="st">&quot;default&quot;</span>, <span class="st">&quot;boot&quot;</span>, <span class="st">&quot;sched&quot;</span>, 
                                  <span class="st">&quot;gas&quot;</span>, <span class="st">&quot;lco&quot;</span>, <span class="st">&quot;net&quot;</span>, <span class="st">&quot;trans&quot;</span>, 
                                  <span class="st">&quot;parcel&quot;</span>, <span class="st">&quot;action&quot;</span>, <span class="st">&quot;config&quot;</span>, 
                                  <span class="st">&quot;memory&quot;</span>, <span class="st">&quot;all&quot;</span>)</code></pre>
<p>The logging options <code>--hpx-log-at</code> and <code>--hpx-log-level</code> produce logging output for selected subsystems at selected localities. If no locality is selected, all localities will produce log messages. Log messages are not errors. Instead, they provide an insight into what the HPX runtime is doing &quot;under the hood.&quot;</p>
<h4 id="debugging-options">Debugging Options</h4>
<p>Note that in order to use the debugging options, <code>--enable-debug</code> must be set during configuration.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">HPX</span> Debug Options:
      <span class="kw">--hpx-dbg-waitat</span>=[locality]
                                <span class="kw">wait</span> for debugger at specific locality
      <span class="kw">--hpx-dbg-waitonabort</span>     call hpx_wait() <span class="kw">inside</span> of hpx_abort() <span class="kw">for</span> 
                                  <span class="kw">debugging</span>  (default=off)
      <span class="kw">--hpx-dbg-waitonsegv</span>      call hpx_wait() <span class="kw">for</span> <span class="kw">SIGSEGV</span> for debugging 
                                  <span class="kw">(unreliable)</span>  <span class="kw">(</span><span class="ot">default=</span>off<span class="kw">)</span>
      <span class="kw">--hpx-dbg-mprotectstacks</span>  use mprotect() <span class="kw">to</span> bracket stacks to look for 
                                  <span class="kw">stack</span> overflows  (default=off)</code></pre>
<p>The <code>wait</code> options in the debug section provide a way to stop the hpx runtime and wait for a debugger to be attached. The <code>–hpx-dbg-waitat</code> option causes HPX to stop at start of the application. A wait loop will be executed. The loop can be broken in the debugger with the following commands (assuming a freshly attached gdb):</p>
<pre><code>up 2
p i=1
c</code></pre>
<p>The two other <code>wait</code> options work in the same way. It is important to note that the <code>--hpx-dbg-waitonsegv</code> is implemented using non-portable techniques, and it is not guaranteed to work on all systems.</p>
<p>The <code>--hpx-dbg-mprotectstacks</code> uses the <code>mprotect()</code> interface to protect memory pages around task stacks. This provides a way to debug stack overflows, but if the incorrect memory access skips the proteceted page, the problem will not be detected.</p>
<h4 id="tracing-options">Tracing Options</h4>
<p>Note that in order to use the tracing interface, hpx must be compiled with the <code>--enable-instrumentation</code> option set.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">      <span class="kw">--hpx-trace-classes</span>=class set the event classes to trace  (possible 
                                  <span class="ot">values=</span><span class="st">&quot;parcel&quot;</span>, <span class="st">&quot;pwc&quot;</span>, <span class="st">&quot;sched&quot;</span>, 
                                  <span class="st">&quot;all&quot;</span>)
      <span class="kw">--hpx-trace-dir</span>=dir       directory to output trace files
      <span class="kw">--hpx-trace-filesize</span>=# of events
                                <span class="kw">set</span> <span class="kw">the</span> size of each trace file
      <span class="kw">--hpx-trace-at</span>=[localities]
                                <span class="kw">set</span> <span class="kw">the</span> localities to trace at</code></pre>
<p>There are four options that affect tracing:</p>
<ul>
<li><code>--hpx-trace-dir=&lt;directory name as string&gt;</code> (defaults to <code>&quot;/tmp&quot;</code> - which is strongly recommended) which is where the tracing infrastructure will save the traces</li>
<li><code>--hpx-trace-filesize=&lt;size as unsigned integer&gt;</code> which is a limit on the maximum trace file size</li>
<li><code>--hpx-trace-classes=&lt;list of classes as strings&gt;</code> which is the “class” of events to trace (possible values are <code>parcel</code>, <code>pwc</code>, <code>sched</code> and <code>all</code>)</li>
<li><code>--hpx-trace-at=&lt;list of ranks as integers&gt;</code> which can be set to a list of ranks at which to trace, or it can be set to <code>HPX_LOCALITY_ALL</code> or <code>HPX_LOCALITY_NONE</code> to turn tracing on or off everywhere</li>
</ul>
<p>Tracing records certain events and writes all the events for one rank to a file within a time-stamped subdirectory (which will be located in the specified trace directory) at that rank. Each event is assigned a time, accurate to the nearest microsecond.</p>
<p>The current trace file format is an ad hoc binary format that can be easily deserialized and processed.</p>
<h4 id="isendirecv-network-options">Isend/Irecv network options</h4>
<pre class="sourceCode bash"><code class="sourceCode bash">      <span class="kw">--hpx-isir-testwindow</span>=requests
                                <span class="kw">number</span> of ISIR requests to test in 
                                  <span class="kw">progress</span> loop
      <span class="kw">--hpx-isir-sendlimit</span>=requests
                                <span class="kw">ISIR</span> network send limit
      <span class="kw">--hpx-isir-recvlimit</span>=requests
                                <span class="kw">ISIR</span> network recv limit</code></pre>
<p>The Isend/Irecv network implementation currently uses MPI Isend/Irecv-inspired two-sided messaging as a transport layer.</p>
<h4 id="pwc-network-options">PWC Network Options</h4>
<pre class="sourceCode bash"><code class="sourceCode bash">      <span class="kw">--hpx-pwc-parcelbuffersize</span>=bytes
                                <span class="kw">set</span> <span class="kw">the</span> size of p2p recv buffers for 
                                  <span class="kw">parcel</span> sends
      <span class="kw">--hpx-pwc-parceleagerlimit</span>=bytes
                                <span class="kw">set</span> <span class="kw">the</span> largest eager parcel size 
                                  <span class="kw">(header</span> inclusive<span class="kw">)</span></code></pre>
<p>The PWC network implementation currently uses Photon <code>put-with-completion</code> inspired messaging as a transport layer. HPX parcels are emulated using eager buffers, and these two options control these buffers.</p>
<p>The <code>parcelbuffersize</code> is used for point-to-point eager parcel sends, and controls how many parcel bytes may be sent between p2p synchronization. The default value is 65k. If there are N localities, then N^2 buffers are allocated.</p>
<p>The <code>parceleagerlimit</code> is used to switch to a rendezvous-send algorithm for parcel transfers. It must be smaller than the <code>parcelbuffersize</code>.</p>
<h4 id="photon-transport-options">Photon Transport Options</h4>
<pre class="sourceCode bash"><code class="sourceCode bash">      <span class="kw">--hpx-photon-backend</span>=type 
                                <span class="kw">set</span> <span class="kw">the</span> underlying network API to use  
                                  <span class="kw">(possible</span> values=<span class="st">&quot;default&quot;</span>, 
                                  <span class="st">&quot;verbs&quot;</span>, <span class="st">&quot;ugni&quot;</span><span class="kw">)</span>
      <span class="kw">--hpx-photon-ibdev</span>=device 
                                <span class="kw">set</span> <span class="kw">a</span> particular IB device (also a 
                                  <span class="kw">filter</span> for device and port
                                  <span class="kw">discovery</span>, e.g. qib0:1+mlx4_0:2)
      <span class="kw">--hpx-photon-ethdev</span>=device
                                <span class="kw">set</span> <span class="kw">a</span> particular ETH device (for CMA 
                                  <span class="kw">mode</span> only)
      <span class="kw">--hpx-photon-ibport</span>=integer
                                <span class="kw">set</span> <span class="kw">a</span> particular IB port
      <span class="kw">--hpx-photon-usecma</span>       enable CMA connection mode  
                                  <span class="kw">(</span><span class="ot">default=</span>off<span class="kw">)</span>
      <span class="kw">--hpx-photon-ledgersize</span>=integer
                                <span class="kw">set</span> <span class="kw">number</span> of ledger entries
      <span class="kw">--hpx-photon-eagerbufsize</span>=bytes
                                <span class="kw">set</span> <span class="kw">size</span> of eager buffers
      <span class="kw">--hpx-photon-smallpwcsize</span>=bytes
                                <span class="kw">set</span> <span class="kw">PWC</span> small msg limit
      <span class="kw">--hpx-photon-maxrd</span>=integer
                                <span class="kw">set</span> <span class="kw">max</span> number of request descriptors
      <span class="kw">--hpx-photon-defaultrd</span>=integer
                                <span class="kw">set</span> <span class="kw">default</span> number of allocated 
                                  <span class="kw">descriptors</span>
      <span class="kw">--hpx-photon-numcq</span>=integer
                                <span class="kw">set</span> <span class="kw">number</span> of completion queues to 
                                  <span class="kw">use</span> (cyclic assignment to ranks)</code></pre>
<h2 id="notes-on-building-hpx-on-arm">Notes on building HPX on ARM</h2>
<p>Here are some notes on building/testing HPX on ARM. This is primarily based on ARMv7 architecture on parallella-16.</p>
<h3 id="ensure-that-you-have-the-required-accessories">Ensure that you have the required accessories</h3>
<ul>
<li>Parallella-16 board</li>
<li>A high quality 2000mA rated 5V DC power supply with 5.5mm OD / 2.1mm ID center positive polarity plug.</li>
<li>An ethernet cable</li>
<li>UART connector to computer</li>
<li>A fan</li>
<li>16 GB Micro SD Card</li>
</ul>
<p>Note:</p>
<ol>
<li><p>The board does get hot so you have to take precautions to cool the board properly. Install the heatsink on the parallella board using the steps in: <a href="http://www.parallella.org/heatsink/">Installing the heatsink on the parallella board</a>. Before letting the board run for hours, ensure that the board doesn't overheat. Using table fan is highly advisable.</p></li>
<li><p>The board is ESD sensitive, please take the necessary precautions.</p></li>
</ol>
<h3 id="create-a-bootable-micro-sd-card">Create a bootable micro-SD Card</h3>
<p>Burn a fresh Micro-SD card using the latest distribution. The details of creating a parallella SD Card can be found from the link <a href="http://www.parallella.org/create-sdcard/">Creating a Parallella SD Card</a>. Under Mac OS X, the way I imaged it was like:</p>
<ul>
<li>Download the debian image from: <a href="http://stout.incntre.iu.edu/parallella/hpx-debian-parallella.img.bz2">HPX Debian parallella image</a> and unzip the image.</li>
</ul>
<p>The image can be flashed directly to your microSD and it contains an updated kernel with usb storage support. It also has openmpi-1.6.5 and libcheck installed with all the other dependencies needed to build hpx. If you just want the updated kernel, check the boot/ subdirectory.</p>
<ul>
<li>Insert the SD Card into your regular computer.</li>
<li>Find the device path of your SD card:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">diskutil</span> list</code></pre>
<ul>
<li>Unmount disk (but don't eject) the card:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">diskutil</span> unmountDisk [device] 
<span class="kw">Example</span>: 
$ <span class="kw">diskutil</span> unmountDisk /dev/disk1</code></pre>
<ul>
<li>Copy the image downloaded to the micro-SD card:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> dd if=[image] of=[device] bs=4m
<span class="kw">Example</span>: 
$ <span class="kw">sudo</span> dd if=hpx-debian-parallella.img of=/dev/disk1 bs=4m</code></pre>
<p>Please be patient, this takes a while.</p>
<ul>
<li>Eject the card:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">diskutil</span> eject [device]</code></pre>
<p>Done!</p>
<h3 id="connect-the-peripherals-and-apply-power">Connect the peripherals and apply power</h3>
<ol>
<li>Insert the Micro-SD card into parallella board.</li>
<li>Connect a UART connector to parallella. The Parallella board has a three pin 3.3V UART header located next to the RJ45 connector. The RXD pin is an input to the board and the TXD pin is an output from the board. The default UART configuration is as follows: (BAUD_RATE=115,200, DATA_BITS=8, STOP_BIT=1, PARITY=NONE, FLOW=XON/XOFF).</li>
<li>Connect ethernet cable</li>
<li>Connect power cable</li>
</ol>
<h3 id="build-and-run-hpx">Build and run HPX</h3>
<ul>
<li>Start the UART tty screen using the command:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> screen  /dev/ttyUSB0 115200</code></pre>
<p>Restart the parallella board and the system will boot and a login screen will appear. Once logged in,</p>
<ul>
<li>Grab the HPX code from the repository and build the code using the following commands:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">./bootstrap</span>
$ <span class="kw">./configure</span> --prefix=/path/to/hpx/installation --with-mpi CFLAGS=<span class="st">&quot;-O0 -g -mcpu=cortex-a9 -mfloat-abi=hard -mfpu=vfpv3&quot;</span> --enable-debug --enable-testsuite --enable-tutorial --enable-apps
$ <span class="kw">make</span> clean
$ <span class="kw">make</span></code></pre>
<p>Note: There are 2 cores on Parallella-16 boards. To run code on both cores set:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">export</span> <span class="ot">hpx_cores=</span>2
$ <span class="kw">export</span> <span class="ot">hpx_threads=</span>2</code></pre>
<h3 id="known-limitations">Known limitations</h3>
<ol>
<li>HPX on ARM works only with SMP and MPI transport.</li>
<li>Since, parallella board has only 1 GB of memory, some of the apps and examples might not work at higher scale due to memory limitation.</li>
</ol>
<h2 id="getting-started-with-hpx-1">Getting Started with HPX</h2>
<p>The remainder of this guide is meant to get you up and running with HPX and to give you some basic information about the HPX environment.</p>
<p>The later section of this guide describe the general layout of the HPX source tree, a simple example using the HPX, and links to find more information about HPX or to get help via e-mail.</p>
<h3 id="unpacking-the-hpx-archives">Unpacking the HPX Archives</h3>
<p>If you have the HPX distribution, you will need to unpack it before you can begin to compile it. The HPX source code is a TAR archive that is compressed with the gzip program.</p>
<p>hpx-x.y.z.tar.gz (Source release for the HPX libraries and tools, x.y.z marks the version number)</p>
<p>Git Mirror<br />The source code for the HPX can be obtained using the command</p>
<pre><code>$ git clone --recursive git@gitlab.crest.iu.edu:extreme/hpx.git</code></pre>
<p>Since the upstream repository is in Subversion, you should use <code>git pull --rebase</code> instead of git pull to avoid generating a non-linear history in your clone. To configure git pull to pass --rebase by default on the master branch, run the following command.</p>
<pre><code>$ git config branch.master.rebase true</code></pre>
<p>We use, the gitflow model for the development. The central repository holds the following main branches with an infinite lifetime:</p>
<ol>
<li><p>master</p></li>
<li><p>develop</p></li>
<li><p>hotfix</p></li>
</ol>
<p>We consider origin/master to be the main branch where the stable version of the source code exists, which reflects a production-ready state.</p>
<p>We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest developmental changes for the next release. When the source code in the develop branch is released, all of the changes will be merged into master branch and tagged with a release number.</p>
<h3 id="hpx-program-layout">HPX program Layout</h3>
<p>One useful source of information about the HPX source base is the HPX doxygen documentation available at hpx/docs. The following is a brief introduction to code layout:</p>
<p><code>hpx/bench</code> - NetBench, is a parcel based ping-pong test.</p>
<p><code>hpx/contrib</code> - consists of libraries which are embedded with HPX.</p>
<ol>
<li><p><code>hpx/controb/hwloc-1.10.0</code> - hwloc library helps to obtain the hierarchical map of key computing elements, such as: NUMA memory nodes, shared caches, processor sockets, processor cores, processing units (logical processors or &quot;threads&quot;) and even I/O devices. It gathers various attributes such as cache and memory information. Additionally it also assembles the topology information of the entire cluster at once.</p></li>
<li><p><code>hpx/contrib/uthash-fe01a6ad1b</code> - This is used for hash table lookup using a key.</p></li>
<li><p><code>hpx/contrib/jemalloc</code>, <code>hpx/contrib/jemalloc_hpx</code> - It is a general purpose malloc implementation that emphasizes fragmentation avoidance and scalable concurrent support.</p></li>
<li><p><code>hpx/contrib/photon</code> - Photon is a network backend for HPX. Photon can take advantage of RDMA over IB resulting in better performance.</p></li>
<li><p><code>hpx/contrib/valgrind</code> - valgrind is a memory error detector library. It can detect accessing memory one shouldn't, using undefined values, incorrect freeing of memory, overlapping src and dest pointers in memcpy and related functions, passing a negative value to the size parameter of a memory allocation function and memory leaks.</p></li>
<li><p><code>hpx/contrib/libffi</code> - is a foreign function interface library. It provides a C programming language interface for calling naively compiled functions given information about the target function at run time instead of compile time. It also implements opposite functionality: lib can produce a pointer to a function that can accept and decode any combination of arguments defined at run time. libffi is most ofter used as bridging technology between compiled and interpreted language implementations. It can also be used to implement plugin's, where the plugin's function signature are not known at the time of creating the host application.</p></li>
</ol>
<p><code>hpx/examples</code><br />This directory contains some simple examples of how to use the HPX.</p>
<p><code>hpx/include</code><br />This directory contains public header files used for HPX. The three main subdirectories of this directory are:</p>
<ol>
<li><p><code>hpx/include/hpx</code><br />This directory consist all of the HPX specific header files. This folder has types and functions defined for HPX actions, global addresses, attribute definitions, built-in compiler functions, futures, functions for allocating and using memory in the HPX global address space, HPX LCO interface, HPX parcel interface, HPX parallel loop interface, HPX process creation, HPX remote procedure call interface, HPX system interface, HPX thread interface, HPX high-resolution timer interface and HPX topology interface.</p></li>
<li><p><code>hpx/include/libhpx</code><br />This directory has types and functions defined for libhpx source directory. It deals with header files for bootstrapper, configuring HPX at run-time, locality, interface to the parcel network subsystem, gas, internal interface to the scheduler and HPX scheduler statistics, system, transport, worker threads, and util.</p></li>
<li><p><code>hpx/include/libsync</code><br />This directory consists of types and functions defined for libsync source directory. These have functions defined for CAS (counter pointer), a workstealing deque implementation, generic type definitions, lockable pointer, locks, M&amp;S two lock queues, single produce-single consumer concurrent queue, barriers, hashtable, synchronization primitives and atomics used in libhpx. It also has header file definition for synchronization and atomics interface in terms of craycc and gcc compiler.</p></li>
</ol>
<p><code>hpx/libhpx</code> - Contains source code for HPX implementation - HPX actions, bootstrapping, HPX calls, functions for debugging HPX, GAS (Global Address Space - smp, pgas), network layer, scheduler code (LCOs - collectives, channels, cvar, future, gencount, netfuture, semaphores, thread and worker code), and system related code.</p>
<p><code>hpx/libsync</code> - This consist of code for built in functions for atomic memory access and memory model aware atomic operations. Atomic variables are primarily used to synchronize shared memory accesses between threads.</p>
<p><code>hpx/tests</code> - This consist of unit and performance testsuite for HPX. The unit tests are based on check unit test framework. They do not cover all of the HPX API but parcels, threads, LCOs, and the global memory system have tests.</p>
<p><code>hpx/tutorial</code> - This consist of tutorial examples for beginners who are starting with HPX.</p>
<h2 id="an-example-using-the-hpx-runtime-system">An Example Using the HPX Runtime System</h2>
<p>This section explains the simple hello example. Writing applications with HPX is not difficult. The HPX API conforms to the usual semantics of the host language C. As any introduction to a new programming paradigm, we begin with writing the smallest possible program, &quot;Hello World&quot;. It explains the basic concept of HPX. The source code for this example can be found in hpx/examples/hello.c.</p>
<p>The &quot;Hello World!&quot; of HPX looks like</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;hpx/hpx.h&gt;

static int _hello_action(void *args) {
  printf(&quot;Hello World from %u.\n&quot;, hpx_get_my_rank());
  hpx_shutdown(HPX_SUCCESS);
}

int main(int argc, char *argv[argc]) {
  if (hpx_init(&amp;argc, &amp;argv) != 0)
    return -1;
  hpx_action_t hello;
  HPX_REGISTER_ACTION(_hello_action, &amp;hello);
  return hpx_run(&amp;hello, NULL, 0);
}</code></pre>
<p>We have to include a single file hpx.h</p>
<pre><code>#include&lt;hpx/hpx.h&gt;</code></pre>
<p>which imports all necessary declarations, for our HPX program. The program itself defines two functions: <code>main</code> and <code>_hello_action</code>.</p>
<p>As usual for any C program, the execution begins with the function main where all the action has to happen. In our case we use this function to initialize the HPX runtime system by calling <code>hpx_init</code>, which initializes the scheduler, network, global address space and locality. <code>hpx_init()</code> has to be called before any other HPX functions. Then we register the HPX action <code>_hello_action</code> using the macro <code>HPX_REGISTER_ACTION</code>. This should be called by the main native thread only, between the execution of <code>hpx_init()</code> and <code>hpx_run()</code>. This should not be called from an HPX lightweight thread.</p>
<p>Once the action is registered, main returns with <code>hpx_run(&amp;hello, NULL, 0)</code>; which executes the action <code>_hello_action</code> as an HPX-thread. An action is a wrapper for a function. By wrapping functions, HPX can send packets of work to different processing units. <code>HPX_REGISTER_ACTION</code> takes the name of the function that is to be wrapped and the name of the action that you are creating.</p>
<p>The function main returns only after <code>_hello_action</code> has returned and one of the HPX threads has called <code>hpx_shutdown</code>. It returns the value, which has been returned by <code>_hello_action</code> (in our case it will return HPX_SUCCESS).</p>
<p><code>hpx_run()</code> is called to run HPX. It starts the HPX runtime, and runs a given action. This creates an HPX &quot;main&quot; process, and calls the given action entry in the context of this process. The entry action is invoked only on the root locality. On termination, it deletes the main process and returns the status returned by the <code>hpx_shutdown()</code>. <code>hpx_run()</code> finalizes action registration, starts up any scheduler and native threads that need to run, and transfers all control into the HPX scheduler, beginning execution of the top action in the scheduler queue.</p>
<p>The <code>_hello_action</code> prints &quot;Hello World from 0&quot; and shuts down the HPX runtime system using the function <code>hpx_shutdown(HPX_SUCCESS)</code>; This terminates the scheduler and network. This causes the <code>hpx_run()</code> in the main native thread to return the code. The returned thread is executing the original native thread, and all supplementary scheduler threads and network will have been shutdown, and any library resources will have been cleaned up.</p>
<p>This program will print out the hello world message. The output of this program will look like this: Hello World from 0.</p>
<h2 id="development-systems">Development Systems</h2>
<p>HPX has been developed and tested on the following systems:</p>
<ul>
<li><p>C-SWARM at C-SWARM. The C-SWARM cluster has 72 Dual 8-core Intel Xeon E5-2650 v2 CPUs running at 2.60GHz, with 32 GBs or RAM. The interconnect uses Infiniband FDR Non-Blocking Mellanox HBA.</p></li>
<li><p>Cutter at CREST. Cutter is a cluster at CREST used for HPX development. It consists of 16 nodes with 32 GBs of RAM running dual 2.6 GHz Intel Xeon E5-2670s for a total of 16 cores per-node. Cutter runs Ubuntu 12.04.5.</p></li>
<li><p><a href="https://kb.iu.edu/d/bcqt">Big Red II</a> at Indiana University is a Cray XE6/XK7 with 1020 compute nodes. Nodes are a mix of dual AMD Opteron 16-core Abu Dhabi CPUs with 64 GBs of RAM, and single Opteron 16-core Interlagos CPUs and an NVIDIA Tesla K20 Gpu accelerator with 32 GBs of RAM. All compute nodes are connected through the Cray Gemini interconnects. Big Red II runs Cray Linux Environment (based on SUSE Linux SLES 11).</p></li>
<li><p><a href="https://www.nersc.gov/users/computational-systems/edison/">Edison</a> at the National Energy Research Scientific Computing Center is a Cray XC30. Edison's queues support job sizes up to 5462 nodes (131,088 cores). Edison nodes have dual 12-core Intel Xeon E5-2695 v2 CPUs at 2.40GHz and 64 GB of RAM.</p></li>
<li><p><a href="https://portal.tacc.utexas.edu/user-guides/stampede#overview">Stampede</a> at the Texas Advanced Computing Center consists of more than 6400 nodes with dual Intel Xeon E5-2680 CPUs running at 2.8 GHz with an additional Intel Xeon Phi SE10P Coprocessor and 32 GBs of RAM (with an additional 8 GBs available for coprocessors). Large memory nodes are also available. The OS is CentOS release 6.6. The network on Stampede uses Mellanox FDR InfiniBand. Normal production runs are limited to 256 nodes.</p></li>
</ul>
</body>
</html>
